/*
 * ================================================================
 * This file includes (A TEXTUAL REPRESENTATION of) A MODEL 
 * of the software system (expressed using the language/metamodel qak)
 * as the result of PROJECT PHASE.
 * 
 * NOV 2019: added the idea of (sonar) data stream
 * ================================================================
 */   
System basicrobot        
  
mqttBroker "localhost" : 1883  

Dispatch cmd      : cmd(X)					//sent by an external user interface

Event  userCmd    : userCmd(X)				//generated by (web) user interface
Event  obstacle   : obstacle( DISTANCE )	//generated by sonaractorfilter.kt
Event  alarm      : alarm( V )   			//generated by the external world
Event  sonarRobot : sonar( D )				//NOT generated (at the moment) since sonaractorfilter
Event  polar      : polar( D,Angle)			//generated by sonarforradar

Request onestep   : onestep( TIME )		    //to test  the request
Reply   stepdone  : stepdone(V)  
Reply   stepfail  : stepfail(DURATION, CAUSE)

Event virtualobstacle  : virtualobstacle( OBJNAME )  //added DEC19 (for remove)

Context ctxBasicRobot ip [ host= "localhost" port= 8018 ]   //+mqtt  
   
/*  
 * QActor defined in kotlin that 'transforms' a cmd:cmd(X) into 
 * a command to the concrete robot specified in basicRobotConfig.pl
 */
CodedQActor robotadapter context ctxBasicRobot 
		//className "itunibo.robot.robotAdapterQa"	    //OCT 2019
		className "itunibo.robot.robotAdapterQaStream"  //NOV 2019

QActor basicrobot context ctxBasicRobot{ 
	
["
var StepTime      = 0L
var Duration      = 0 
"]	

	State s0 initial{  
		["  
		//The PIPE IS created by the itunrobotAdapterQaStream
		//WARNING: use myself to denote the basicrobot actor, since this refers to the state
		 
		//val filter = itunibo.robot.rx.sonaractorfilter(\"filter\", myself)  //generates obstacle
		//val logger = itunibo.robot.rx.Logger(\"logger\")
		
		//val forradar = itunibo.robot.rx.sonarforradar(\"forradar\", myself)  //generates polar
		//itunibo.robot.robotSupport.subscribe( forradar ) 
		
		//A server with reference to the current actor:
		httpserver.serverinit( myself  ) //default: consolegui.ConnectionType.COAP 
		
		//A server with reference just to the actor name:
		httpserver.serverinit( myself.name, 8018  ) //default: consolegui.ConnectionType.COAP 
		//httpserver.serverinit( myself.name, 8018, connQak.ConnectionType.TCP )  
		//httpserver.serverinit( myself.name, 1883, connQak.ConnectionType.MQTT )  
		"]    
		run consolegui.consoleGuiTcp.create( "localhost", "8018", "basicrobot" )  
		println("	basicrobot | starts (with robotadapter in the same context)") 
 	}
	Goto work        
	
	State work{ println("basicrobot waiting ... ")}
	Transition t0 
			whenMsg cmd          -> handleCmd
			whenEvent userCmd    -> handleUserCmd
			whenEvent obstacle   -> handleObstacle
			whenEvent alarm      -> handleAlarm
			whenRequest onestep  -> doStep
   
   	State doStep{ 
 		//printCurrentMessage  
		onMsg( onestep : onestep( T ) ){
			["StepTime = payloadArg(0).toLong() 
 			  startTimer()"]	//REQUIREMENT req-onestep-time
			println("basicrobot | doStep StepTime =$StepTime ")
			forward robotadapter -m cmd : cmd( w )  //ATTEMPT TO MOVE ...
		}  
	}  
	Transition t0 
		whenTimeVar StepTime      -> stepDone	
  	    whenEvent virtualobstacle -> stepFail//Virtual : see smartrobot (subsumption)
		whenEvent obstacle        -> stepFail
 	
	State stepDone{  //REQUIREMENT  req-onestep-info
		forward robotadapter -m cmd : cmd( h ) 
  		replyTo onestep with stepdone : stepdone(ok)
  	}
	Goto work
	
	State stepFail{ //REQUIREMENT req-onestep-time, req-onestep-info
		["Duration=getDuration()"]  
		//getDuration(): built-in (with ref. to startTimer)
		replyTo onestep with stepfail : stepfail($Duration, obstacle)
		//println("basicrobot | stepFail Duration=$Duration ")
   	}
	Goto work 
	
 /*
  * Alarms
  */  
	State handleAlarm{  //rotate 180
		printCurrentMessage
		forward robotadapter -m cmd : cmd( r )
		delay 800 
		forward robotadapter -m cmd : cmd( r )
	}
	Goto work  
 
 /*
  * REQUIREMENT req-cmd 
  */
	State handleCmd {    
 		printCurrentMessage 
		onMsg( cmd : cmd(X) ){  //redirect the command to the robotadapter
			//println("	basicrobot | redirect userCmd to robotadapter ")
 			forward robotadapter -m cmd : cmd( $payloadArg(0 ) )
		}
	}
	Goto work
	
	State handleUserCmd {    
 		printCurrentMessage 
		onMsg( userCmd : userCmd(X) ){  //redirect the command to the robotadapter
			//println("	basicrobot | redirect cmd to robotadapter ")
 			forward robotadapter -m cmd : cmd( $payloadArg(0 ) )
		}
	}
	Goto work
	
/*
 * Introduced after problem analysis
 */	
	State handleObstacle{
		forward robotadapter -m cmd : cmd( h )
		println("	basicrobot | stops (for safety) since  obstacle  ")
 	}
 	Goto movefarFromObstacle 	//Added after introducing the real robot
	 
	State movefarFromObstacle{
		println("	basicrobot | going back (to avoid event-generation) ")
 		forward robotadapter -m cmd : cmd( s )
		delay 100
		forward robotadapter -m cmd : cmd( h )
	}
	Goto work	 
}  

/*
 * The actor sentinel is introduced for internal work only.
 * It will be removed from final product deployment.
 */
 QActor sentinel context ctxBasicRobot{
	State s0 initial{ 
		delay 1000 
		println("	sentinel | STARTS")
	} 
	Goto work
	
	State work{  }
	Transition t0 
 		whenEvent sonarRobot -> showTheMsg
		whenEvent alarm      -> showTheMsg

	State showTheMsg{
		printCurrentMessage
	}
   	Goto work
 }
